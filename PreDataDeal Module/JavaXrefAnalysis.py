# +
# -*- coding: utf-8 -*-
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# pytx documentation build configuration file, created by
# Author:MengXuan Chen
# date:2024.3.29
# Institute:JSPI

import numpy as np
import networkx as nx
import scipy as sp
import pandas as pd
import matplotlib.pyplot as plt
import os
import re
from PIL import Image
import cv2


# -

#java代码分析模块
class JavaVocab():
    def __init__(self,filepath):
        self.file=filepath #java代码文件的路径
        self.JavaClassCode=[] #批量保存类中代码
        self.FinalState=[]
        self.FilterString=['public','private','protected','enum','interface','static','class','implemented','extends','abstract'] #过滤掉的一些java关键字
     
    #通过括号匹配确定class代码范围
    def read(self):
        with open(self.file,'r',encoding='utf8') as f:
            linelist=f.readlines()
            #print(linelist)
            for idx,line in enumerate(linelist):
                if 'class' in line:
                    flag,mark=idx,['{']
                    while '{' not in linelist[flag]:#确定第一个{的位置
                        flag+=1
                    flag+=1
                    while len(mark)>0:
                        if '{' in linelist[flag]:#遇到{会累加
                            mark.append('{')
                            #print(mark)
                        if '}' in linelist[flag]:#遇到}就会取出匹配的{号
                            mark.pop(-1)
                        flag+=1
                        #print(flag)
                    self.JavaClassCode.append('.'.join(linelist[idx:flag]))
        return self.JavaClassCode
         
    #对一些特殊字符进行过滤处理
    def deal_code(self,string):
        replace_string=[]
        forbid_idx=[]
        for idx,char in enumerate(string):
            #print(char)
            if char=='\n' and idx+1<len(string):
                if string[idx+1]=='.':
                    forbid_idx.append(idx+1)
                elif string[idx+1]=='\'' or '\"':
                    continue
                #print(char)
                replace_string.append(char)
            else:
                if idx not in forbid_idx:
                    replace_string.append(char)
        return ''.join(replace_string)
    
    def split_code(self):
        for ClassCode in self.JavaClassCode:
            replace_code=self.deal_code(ClassCode)
            new_code=replace_code.split('\n')
            self.FinalState.append(new_code)
        return self.FinalState
    
    def add(self,dic,key,value):
        if key not in dic:
            dic[key]=[value]
        else:
            dic[key].append(value)
    
    def abstract_object(self):
        pattern=r"[a-zA-Z0-9_]+"
        Class,from_class,to_class=[],{},{}
        for code_list in self.FinalState:
            MainClass=None
            for idx,line in enumerate(code_list):
                character_list=re.findall(pattern,line)
                real_class=[]
                if idx==0:
                    for s in character_list:
                        if s not in self.FilterString:
                            real_class.append(s)
                    if len(real_class)==1:
                        Class.append(real_class[0])
                    elif len(real_class)==2:
                        Class.append(real_class[0])
                        Class.append(real_class[1])
                        self.add(from_class,real_class[0],real_class[1])
                        self.add(to_class,real_class[1],real_class[0])
                    MainClass=real_class[0]
                else:
                    if 'new' in character_list and '=' in line:
                        class1,class2=character_list[0],character_list[-1]
                        if class1==class2:
                            self.add(from_class,MainClass,class1)
                            self.add(to_class,class1,MainClass)
                        else:
                            self.add(from_class,MainClass,class1)
                            self.add(from_class,MainClass,class2)
                            self.add(to_class,class1,MainClass)
                            self.add(to_class,class2,MainClass)
        self.Class,self.from_class,self.to_class=Class,from_class,to_class
        self.unduplicateed()
        return Class,from_class,to_class
    
    def unduplicateed(self):
        for key,value in self.from_class.items():
            self.from_class[key]=list(set(value))
        for key,value in self.to_class.items():
            self.to_class[key]=list(set(value))
        self.Class=list(set(self.Class))
            
    def run(self):
        self.read()
        self.split_code()
        self.abstract_object()
        return self.Class,self.from_class,self.to_class


class JavaMainVocab():
    def __init__(self,dirpath):
        self.dir=dirpath
        self.Class,self.from_class,self.to_class=[],{},{}
        self.filepath=[]
        
    def search_path(self):
        dir_path = self.dir
        for dirpath, dirnames, filenames in os.walk(dir_path):
            for filename in filenames:
                self.filepath.append(os.path.join(dirpath, filename))
                
    def split(self,nowpath,object_list):
        workdir_temp=os.path.dirname(nowpath).replace('.','')
        workdir=workdir_temp.replace('\\','.')
        #print(type(workdir))
        Value=None
        if type(object_list)==list:
            Value=[]
            for item in object_list:
                Value.append(workdir+'.'+item)
        elif type(object_list)==dict:
            Value={}
            for key,value in object_list.items():
                new_key,new_value=workdir+'.'+key,[]
                for child_value in value:
                    new_value.append(workdir+'.'+child_value)
                Value[new_key]=new_value
        return Value
        
    def forward(self):
        self.search_path()
        for file in self.filepath:
            model=JavaVocab(file)
            try:
                answer_pre=model.run()
            except IndexError:
                continue
            answer_now=[]
            for child in answer_pre:
                new_child=self.split(file,child)
                answer_now.append(new_child)
            self.Class.extend(answer_now[0])
            #print(answer_now[1])
            self.from_class=self.merge(self.from_class,answer_now[1])
            self.to_class=self.merge(self.to_class,answer_now[2])
            #print(answer_now[0])
        return self.Class,self.from_class,self.to_class
    
    def merge(self,dict1,dict2):  
        res = {**dict1, **dict2}  
        return res
    
    #def add(self):
        #for 


model=JavaMainVocab(r"..\FILE Module\cmx2")
model.forward()
#model.Class

model.to_class


class Graph(JavaMainVocab):
    def __init__(self,dirpath):
        super().__init__(dirpath)
        self.G=nx.Graph()
        
    def dict2list(self,data):
        feature=[]
        for key,value in data.items():
            for item in value:
                feature.append((key,item))
        return feature
    
    def create(self):
        Node,dict_edge,_=super().forward()
        Edge=self.dict2list(dict_edge)
        self.G.add_nodes_from(Node)
        self.G.add_edges_from(Edge)
        
    def draw_network(self,pos,**kwds):
        nx.draw(self.G,pos(self.G),**kwds)
        plt.show()
        
    def get_matrix(self):
        matrix=np.array(nx.adjacency_matrix(self.G).todense())
        return matrix
    
    def run(self):
        self.create()
        return self.get_matrix()


model_child=Graph(r"..\FILE Module\cmx2")
model_child.run()

model_child.draw_network(pos=nx.spring_layout,edge_color='k',node_size=1,node_color='r',node_shape='o')


class ImageModule():
    def __init__(self,matrix):
        self.matrix=255*matrix
        self.img=Image.fromarray(self.matrix)
    
    def show_image(self):
        self.img.show()
        
    def resize(self,height,width):
        points=(height,width)
        self.img=self.img.resize(points)
        return np.asarray(self.img)


matrix=model_child.get_matrix()
modelw=ImageModule(matrix)
modelw.resize(224,224)


