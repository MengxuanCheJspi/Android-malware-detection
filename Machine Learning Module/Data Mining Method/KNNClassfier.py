import pandas as pd
import numpy as np
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import sklearn
from sklearn.neighbors import KNeighborsClassifier as KNN
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.model_selection import GridSearchCV
import os


class KNNClassfier():
    def __init__(self,X_train,Y_train,X_test,Y_test,is_init=True,is_pca=False,parameters=None,num=2):
        self.X=X_train
        self.Y=Y_train
        self.X_t,self.Y_t=X_test,Y_test
        self.model=None
        self.is_init=is_init
        self.is_pca=is_pca
        self.parameters=parameters
        self.num=num
        self.stdScaler=None
        self.pca=None
        
    def model_init(self,X_train,Y_train):
        if self.parameters is None:
            self.parameters={'n_neighbors':np.arange(3,10),'weights':['uniform','distance'],'p':[1,2]}
        knn=KNN()
        grid_search = GridSearchCV(knn,self.parameters,cv=5,scoring='accuracy')
        grid_search.fit(X_train,Y_train)
        return grid_search.best_params_
    
    def init_data(self,data):
        stdScaler = StandardScaler().fit(self.X)
        self.stdScaler=stdScaler
        trainStd = stdScaler.transform(data)
        if self.is_pca:
            pca = PCA(n_components=self.num).fit(stdScaler.transform(self.X))
            trainStd=pca.transform(trainStd)
            self.pca=pca
        return trainStd
    
    def forward(self):
        train_X,train_Y=self.init_data(self.X),self.Y
        if self.is_init:
            best_params=self.model_init(train_X,train_Y)
            model=KNN(**best_params)
        else:
            model=KNN()
        self.model=model.fit(train_X,train_Y)
        return model.score(train_X,train_Y)
    
    def validate(self):
        Validate_X,Validate_Y=self.init_data(self.X_t),self.Y_t
        return self.model.score(Validate_X,Validate_Y)
    
    def predict(self,X):
        X_predict=self.init_data(X)
        return self.model.predict(X_predict)

    def arg_plot(self,kind,arg,weights):
        train_X, train_Y = self.init_data(self.X), self.Y
        test_X,test_Y=self.init_data(self.X_t), self.Y_t
        for item in weights:
            accuracy,param_dict=[],{}
            for num in arg:
                param_dict[kind]=num
                model=KNN(weights=item,**param_dict)
                model.fit(train_X,train_Y)
                accuracy.append(model.score(test_X,test_Y))
                print(num)
            plt.plot(arg,accuracy)
        plt.legend(weights)
        plt.show()
    
    def compoment_draw(self,min_dim=2,max_dim=None,is_init=None):
        if max_dim==None:
            max_dim=self.dim+1
        if is_init==None:
            is_init=self.is_init
        train_X_temp=self.stdScaler.transform(self.X)
        test_X_temp=self.stdScaler.transform(self.X_t)
        accuracy=[]
        for n_dim in range(min_dim,max_dim):
            pca=PCA(n_components=n_dim).fit(train_X_temp)
            train_X,train_Y=pca.transform(train_X_temp),self.Y
            test_X,test_Y=pca.transform(test_X_temp), self.Y_t
            if is_init:
                best_params=self.model_init(train_X,train_Y)
                model=KNN(**best_params)
            else:
                model=KNN()
            model.fit(train_X,train_Y)
            accuracy.append(model.score(train_X,train_Y))
        plt.plot(list(range(min_dim,max_dim)),accuracy)
        plt.show()


dataset = pd.read_csv(r"./final_opcodes_finaldataset.csv").values
X ,Y= dataset[:,1:],dataset[:,0]
print(X,Y)
#print(X,Y)
model=KNNClassfier(X,Y,is_init=True)
print(model.forward())
model.arg_plot('p',np.arange(1,10),['distance'])
print(model.predict(X))
#model.compoment_draw()


