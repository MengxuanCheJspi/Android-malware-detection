from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt
import torch
from torch import nn
import sys

sys.path.append(r'C:\Users\admin')
sys.path.append(r'..')
from torch.nn import functional as F
from d2l import torch as d2l
import os

os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
from PIL import Image
import numpy as np
from torchvision import transforms, datasets
import random
from sklearn.metrics import confusion_matrix, classification_report
from NeuralNetwork.CBAM import CBAM_ResNet, ChannelAttention, SpatialAttention
from NeuralNetwork.CBAM import CBAM_Bottleneck, CBAM_BasicBlock, conv1x1, conv3x3
from NeuralNetwork.ViT import PatchEmbedding, ViTMLP, ViTBlock, ViT
from NeuralNetwork.ResNet import Residual, resnet_block
from NeuralNetwork.DenseNet import conv_block, DenseBlock, transition_block
from NeuralNetwork.GoogLeNet import Inception
# from torchvision.transforms import transforms
from torch.utils import data
import seaborn as sns
import matplotlib.pyplot as plt

# dataroot = 'dataset/'
transform_224 = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])
transform_96 = transforms.Compose([
    transforms.Resize((96, 96)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

# %%
# 定义图像预处理步骤
data_transform = transforms.Compose([
    transforms.RandomResizedCrop(224),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# 加载图像数据集
image_dataset_224 = datasets.ImageFolder(root=r"E://DexSingle", transform=transform_224)
image_dataset_96 = datasets.ImageFolder(root=r"E://DexSingle", transform=transform_96)
# 创建数据加载器
dataloader_224 = torch.utils.data.DataLoader(image_dataset_224, batch_size=128, shuffle=True, num_workers=0)
dataloader_96 = torch.utils.data.DataLoader(image_dataset_96, batch_size=128, shuffle=True, num_workers=0)


# %%
def evaluate_model(model, dataloader, idx=10):
    model.eval()  # 设置模型为评估模式
    true_labels = []
    pred_labels = []
    num = 0
    with torch.no_grad():
        for inputs, labels in dataloader:
            inputs, labels = inputs.to('cuda'), labels.to('cuda')
            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            true_labels.extend(labels.cpu().numpy())
            pred_labels.extend(preds.cpu().numpy())
            if num == idx:
                break
            num += 1
    label_dict = {0: 'Malware', 1: 'Benign'}

    # print(y_true_labels)
    # 计算混淆矩阵
    conf_mat = confusion_matrix(true_labels, pred_labels)
    print(f'Confusion Matrix: \n{conf_mat}')

    # 计算分类报告
    class_report = classification_report(true_labels, pred_labels, target_names=['Malware', 'Benign'])
    print(f'Classification Report: \n{class_report}')

    plt.figure(figsize=(10, 7))
    sns.heatmap(conf_mat, annot=True, fmt='d', xticklabels=label_dict.values(), yticklabels=label_dict.values(),
                cmap='coolwarm')

    plt.xlabel('Predicted Class')
    plt.ylabel('Actual Class')
    plt.show()


# %%
model1 = torch.load(r'../Reserved Model/Single/CBAM_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model1, dataloader_224, idx=20)
# %%
model2 = torch.load(r'../Reserved Model/Single/ViT_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model1, dataloader_96, idx=20)
# %%
model3 = torch.load(r'../Reserved Model/Single/ResNet_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model3, dataloader_224, idx=20)
# %%
model4 = torch.load(r'../Reserved Model/Single/DenseNet_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model4, dataloader_224, idx=20)
# %%
model5 = torch.load(r'../Reserved Model/Single/GoogLeNet_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model5, dataloader_96, idx=20)
# %%
model6 = torch.load(r'../Reserved Model/Single/AlexNet_single')
# 使用你的模型和数据加载器调用函数
evaluate_model(model6, dataloader_224, idx=20)
# %%
