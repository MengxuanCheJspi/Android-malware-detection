from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt
import torch
from torch import nn
import sys
sys.path.append(r'C:\Users\admin')
sys.path.append(r'..')
from torch.nn import functional as F
from d2l import torch as d2l
import os
os.environ["KMP_DUPLICATE_LIB_OK"]  =  "TRUE"
from PIL import Image
import numpy as np
from torchvision import transforms, datasets
import random
from sklearn.metrics import confusion_matrix, classification_report
from NeuralNetwork.CBAM import CBAM_ResNet,ChannelAttention,SpatialAttention
from NeuralNetwork.CBAM import CBAM_Bottleneck,CBAM_BasicBlock,conv1x1,conv3x3
from NeuralNetwork.ViT import PatchEmbedding,ViTMLP,ViTBlock,ViT
from NeuralNetwork.ResNet import Residual,resnet_block
from NeuralNetwork.DenseNet import conv_block,DenseBlock,transition_block
from NeuralNetwork.GoogLeNet import Inception
#from torchvision.transforms import transforms
from torch.utils import data
import seaborn as sns
import matplotlib.pyplot as plt
#dataroot = 'dataset/'
transform_224 = transforms.Compose([
    transforms.Resize((224,224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])
])
transform_96 = transforms.Compose([
    transforms.Resize((96,96)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])
])

#%%
# 定义图像预处理步骤
data_transform = transforms.Compose([
        transforms.RandomResizedCrop(224),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

# 加载图像数据集
image_dataset_224 = datasets.ImageFolder(root=r"E://DexSingle", transform=transform_224)
image_dataset_96 = datasets.ImageFolder(root=r"E://DexSingle", transform=transform_96)
# 创建数据加载器
dataloader_224 = torch.utils.data.DataLoader(image_dataset_224, batch_size=128, shuffle=True, num_workers=0)
dataloader_96 = torch.utils.data.DataLoader(image_dataset_96, batch_size=128, shuffle=True, num_workers=0)
#%%
# 计算ROC曲线
# 假设 y_true 是你的真实类别，y_score 是你的预测分数
# y_true = [...]
# y_score = [...]


def roc_plot(models, dataloader=[dataloader_224,dataloader_96],idx=10,model_names=None):
    fpr_all,tpr_all,roc_auc_all=[],[],[]
    for i,model in enumerate(models):
        testdataloader=dataloader[0]
        if model_names is not None and model_names[i] in ['ViT','GoogLeNet']:
            testdataloader=dataloader[1]
        model.eval()  # 设置模型为评估模式
        true_labels = []
        preds = []
        num=0
        with torch.no_grad():
            for inputs, labels in testdataloader:
                inputs,labels=inputs.to('cuda'),labels.to('cuda')
                outputs_preds = model(inputs)
                true_labels.extend(labels.cpu().numpy())
                preds.extend(outputs_preds[:,1].cpu().numpy())
                if num==idx:
                    break
                num+=1
        fpr, tpr, thresholds = roc_curve(true_labels,preds)

        # 计算AUC（曲线下面积）
        roc_auc = auc(fpr, tpr)
        fpr_all.append(fpr)
        tpr_all.append(tpr)
        roc_auc_all.append(roc_auc)

    # 绘制ROC曲线
    plt.figure()
    lw = 1
    num=0
    color=['green','red','cyan','magenta','purple','pink']
    if model_names is not None:
        for fpr,tpr,roc_auc,model_name in zip(fpr_all, tpr_all,roc_auc_all,model_names):
            plt.plot(fpr, tpr, lw=lw,color=color[num%len(color)] , label=model_name+' ROC curve  (area = %0.2f)' % roc_auc)
            num+=1
    else:
        for fpr,tpr,roc_auc in zip(fpr_all, tpr_all,roc_auc_all):
            plt.plot(fpr, tpr, lw=lw,color=color[num%len(color)] ,label='The '+str(num) +' ROC curve  (area = %0.2f)' % roc_auc)
            num+=1
    plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Model ROC Visualization')
    plt.legend(loc="lower right")
    plt.show()

#%%
model1=torch.load(r'../Reserved Model/Single/CBAM_single')
model2=torch.load(r'../Reserved Model/Single/ViT_single')
model3=torch.load(r'../Reserved Model/Single/ResNet_single')
model4=torch.load(r'../Reserved Model/Single/DenseNet_single')
model5=torch.load(r'../Reserved Model/Single/GoogLeNet_single')
model6=torch.load(r'../Reserved Model/Single/AlexNet_single')
model=[model1,model2,model3,model4,model5,model6]
roc_plot(model, idx=20,model_names=['CBAM','ViT','ResNet','DenseNet','GoogLeNet','AlexNet'])